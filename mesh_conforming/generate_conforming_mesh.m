%% Program PRE_POISSON2D% Interactive code to read a 'prefix.predat' input file% for the poisson2d.m code%% Modified by Marcus Tan on Sep 24% this function generates conforming mesh for given nurbs interface% NOTES: %   (i): % REQUIREMENTS: %   (i): boundary point marks are ordered 1,2,...,num_boun_point  %   (ii): boundary segment marks are ordered 1,2,...,num_boun_seg%   (iii) : different regions separated by the interface have to be%           specified manually% ASSUMPTIONS:%   (i): interfaces must either terminate at a junction or the domain boundary function [mesh,itrface]=generate_conforming_mesh(prefix,triangle_exec,itrface,showNode,showElem)pre_file_name=strcat(prefix,'.predat');          % concatenates prefix and suffixpre_file=fopen(pre_file_name,'r');               % open input file (read only)%problem_title=sscanf(fgets(pre_file),'%s');      % read titlenumat=sscanf(fgets(pre_file),'%d');              % read numatakx=zeros(numat,1);                              % thermal conductivity in x-dir.aky=zeros(numat,1);                              % thermal conductivity in y-dir.q=zeros(numat,1);                                % distributed heat source%for i=1:numat      % read material thermal properties   pars=sscanf(fgets(pre_file),'%d %f %f %f');     akx(i)=pars(2);   aky(i)=pars(3);   if(akx(i)~=aky(i))       error('conductivities, kx=ky')   end   q(i)=pars(4);end% ignore thesepars=sscanf(fgets(pre_file),'%d %d');  numipt=pars(1);      % number of integration points (1 or 3)numgpt=pars(2);      % number of gradient pointssgt=zeros(numgpt,1); % xi-location of gradient pointstgt=zeros(numgpt,1); % eta-location of gradient pointsfor i=1:numgpt   pars=sscanf(fgets(pre_file),'%f %f');     sgt(i)=pars(1);   tgt(i)=pars(2);end%%figure(1);       % figure 1: domain outlineclf;nnopel=sscanf(fgets(pre_file),'%d');          % nnopel = number of nodes per elementswitch_trian=sscanf(fgets(pre_file),'%s');    % switches for 'triangle' mesh generatornum_boun_point=sscanf(fgets(pre_file),'%d');  % number of boundary pointsboun_point_xy=zeros(num_boun_point,2);        % list of boundary pointsnboun_point_mark=zeros(num_boun_point,1);     % markers for boundary pointsfor i=1:num_boun_point                         % for each boundary point, read   pars=sscanf(fgets(pre_file),'%d %f %f %d'); % i, x- and y-locations and marker (see marker convention below)   boun_point_xy(i,1)=pars(2);   boun_point_xy(i,2)=pars(3);   nboun_point_mark(i)=pars(4);                end%%num_boun_seg=sscanf(fgets(pre_file),'%d');    % read number of boundary segmentsnseg_boun=zeros(num_boun_seg,2);nseg_boun_mark=zeros(num_boun_seg,1);nseg_itrface_mcf = zeros(num_boun_seg,1);for i=1:num_boun_seg                           % for each boundary segment, read   pars=sscanf(fgets(pre_file),'%d %d %d %d'); % n, node i, node j, marker (see marker convention below)   nseg_boun(i,1)=pars(2);   nseg_boun(i,2)=pars(3);   nseg_boun_mark(i)=pars(4);endnum_boun_edge = num_boun_seg;% ignore these num_hole=sscanf(fgets(pre_file),'%d');         % read number of holeshole_xy=zeros(num_hole,2);for i=1:num_hole                               % for each hole, read   pars=sscanf(fgets(pre_file),'%d %f %f');    % n, x- and y-locations   hole_xy(i,1)=pars(2);     hole_xy(i,2)=pars(3);end%%num_region=sscanf(fgets(pre_file),'%d');      % read number of regionsregion_xy=zeros(num_region,2);region_area=zeros(num_region,1);nregion_mark=zeros(num_region,1);for i=1:num_region                             % for each region, read   pars=sscanf(fgets(pre_file),'%d %f %f %d %f'); % n, x- and y-location, marker (i.e., material type) and element area   region_xy(i,1)=pars(2);   region_xy(i,2)=pars(3);   nregion_mark(i)=pars(4);   region_area(i)=pars(5);end%%num_boun_val=sscanf(fgets(pre_file),'%d');   % read number of markers%          NOTE: MARKER CONVENTION FOR 2-D POISSON CODE%                  1-10: IMPOSED TEMPERATURE%                 11-20: IMPOSED NORMAL HEAT FLUX%value_imposed=zeros(20,1);for i=1:num_boun_val   pars=sscanf(fgets(pre_file),'%d %f');     n=pars(1);   value_imposed(n)=pars(2);end%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% generate boundary points from interface pointstol = 1e-8;num_boun_point_old = num_boun_point; domainDiagonal = (max(boun_point_xy(:,1))-min(boun_point_xy(:,1)))^2+...                 (max(boun_point_xy(:,2))-min(boun_point_xy(:,2)))^2;             npt0 = ceil(sqrt(domainDiagonal/(2*region_area(1)))); % initial guess of the number of pointsnum_boun_seg_old = num_boun_seg;itrsect = struct('nSeg',cell(1,num_boun_seg_old));for i=1:num_boun_point    itrsect(i).nSeg = 0;endfor i = 1:itrface.nNurbs    maxDistSq = inf;    if(npt0<3)        npt = 3;        xiParam = linspace(0,1,npt);        pt = nrbeval(itrface.nurbs(i),xiParam);    else         % create points on nurbs curve until the maximum distance between adjacent        % points is less than sqrt(region_area(i))        npt = npt0;        while (maxDistSq>=2*region_area(1))               xiParam = linspace(0,1,npt);            pt = nrbeval(itrface.nurbs(i),xiParam);            vec = diff(pt(1:2,:)')';            maxDistSq = max(vec(1,:).^2+vec(2,:).^2);            npt = npt + 1;        end        while (maxDistSq<=2*region_area(1))            npt = npt - 1;            xiParam = linspace(0,1,npt);            pt = nrbeval(itrface.nurbs(i),xiParam);            vec = diff(pt(1:2,:)')';            maxDistSq = max(vec(1,:).^2+vec(2,:).^2);        end    end    %    % check if the start point or end point of the nurbs curve correspond    % to existing boundary points    sPtFlag=false;    ePtFlag=false;    for m = 1:num_boun_point_old        if(~sPtFlag && (abs(boun_point_xy(m,1)-pt(1,1))+abs(boun_point_xy(m,2)-pt(2,1))) < tol)            sPtFlag = true;            ms = m;            pt(:,1) = [];            itrsect(m).nSeg = itrsect(m).nSeg+1;            itrsect(m).seg(itrsect(m).nSeg) = i;            itrsect(m).nurbsParam(itrsect(m).nSeg) = xiParam(1);            xiParam(1) = [];                    end        if(~ePtFlag && (abs(boun_point_xy(m,1)-pt(1,end))+abs(boun_point_xy(m,2)-pt(2,end))) < tol)            ePtFlag = true;            me = m;            pt(:,end) = [];            itrsect(m).nSeg = itrsect(m).nSeg+1;            itrsect(m).seg(itrsect(m).nSeg) = i;            itrsect(m).nurbsParam(itrsect(m).nSeg) = xiParam(end);            xiParam(end) = [];                    end        if(sPtFlag && ePtFlag)            break;        end    end    % check if the start point or end point of the nurbs curve fall on the    % outer most boundaries    sPtonBounFlag = false;    ePtonBounFlag = false;    for b = 1:num_boun_seg_old        line = [boun_point_xy(nseg_boun(b,1),1),boun_point_xy(nseg_boun(b,1),2);                boun_point_xy(nseg_boun(b,2),1),boun_point_xy(nseg_boun(b,2),2)]';         normline = norm(line);        if(~sPtonBounFlag && point_line_dist(pt(1:2,1),line)<tol*normline)            sPtonBounFlag = true;            % check if temperature at the end of the channel at the domain            % boundary is specified                        rowInd = find(itrface.pt_temp(:,1) == itrface.contvty(i,1));            if(~isempty(rowInd))                sPtonBounMark = -rowInd;                            else                sPtonBounMark = nseg_boun_mark(b);            end        end              if(~ePtonBounFlag && point_line_dist(pt(1:2,end),line)<tol*normline)            ePtonBounFlag = true;            % check if temperature at the end of the channel at the domain            % boundary is specified            rowInd = find(itrface.pt_temp(:,1)==itrface.contvty(i,2));            if(~isempty(rowInd))                ePtonBounMark = -rowInd;            else                ePtonBounMark = nseg_boun_mark(b);            end        end         if(sPtonBounFlag && ePtonBounFlag)            break;        end    end        npt=size(pt,2);    k1 = num_boun_point+1;    k2 = num_boun_point+npt;        for j = k1:k2               k = j-k1+1;        boun_point_xy(j,1) = pt(1,k);        boun_point_xy(j,2) = pt(2,k);        nboun_point_mark(j) = 0;        itrsect(j).isItrsect = true;        itrsect(j).nSeg = 1;        itrsect(j).seg(1) = i;        itrsect(j).nurbsParam(1) = xiParam(k);        % set marker of a point to that of domain boundary if it lies on        % the domain boundary        if(j == k1 && sPtonBounFlag)            nboun_point_mark(j) = sPtonBounMark;        end        if(j == k2 && ePtonBounFlag)            nboun_point_mark(j) = ePtonBounMark;        end         % create boundary segments or connectivity of the boundary points                if (j == k1 && sPtFlag);            num_boun_seg = num_boun_seg+1;            nseg_boun(num_boun_seg,1) = ms;            nseg_boun(num_boun_seg,2) = k1;            nseg_boun_mark(num_boun_seg) = 0;            nseg_itrface_mcf(num_boun_seg) = itrface.mcf(i);            %nseg_itrface_mark(num_boun_seg) = i;        elseif(j > k1)            num_boun_seg = num_boun_seg+1;            nseg_boun(num_boun_seg,1) = j-1;            nseg_boun(num_boun_seg,2) = j;            nseg_boun_mark(num_boun_seg) = 0;            nseg_itrface_mcf(num_boun_seg) = itrface.mcf(i);            %nseg_itrface_mark(num_boun_seg) = i;        end        if (j == k2 && ePtFlag)            num_boun_seg = num_boun_seg+1;            nseg_boun(num_boun_seg,1) = j;            nseg_boun(num_boun_seg,2) = me;            nseg_boun_mark(num_boun_seg) = 0;            nseg_itrface_mcf(num_boun_seg) = itrface.mcf(i);            %nseg_itrface_mark(num_boun_seg) = i;        end                    end    num_boun_point = k2;    num_boun_point_old = num_boun_point; enditrfaceInd=num_boun_edge+1:num_boun_seg;itrface.nSeg = length(itrfaceInd);itrface.pts = boun_point_xy;itrface.contvty = nseg_boun(itrfaceInd,:);%itrface.mark = nseg_itrface_mark(itrfaceInd)';itrface.mcf = nseg_itrface_mcf(itrfaceInd);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% create 'prefix.poly' file in a format readable by TRIANGLE%poly_file_name=strcat(prefix,'.poly');poly_file=fopen(poly_file_name,'w');    %fprintf(poly_file,'   %d %d %d %d\n',num_boun_point,2,0,1);iii=1:1:num_boun_point;aux_points=[iii;boun_point_xy(:,1)';boun_point_xy(:,2)';nboun_point_mark(:)'];fprintf(poly_file,'%6d %14.6e %14.6e %4d\n',aux_points);%fprintf(poly_file,'   %d %d\n',num_boun_seg,1);iii=1:1:num_boun_seg;aux_segments=[iii;nseg_boun(:,1)';nseg_boun(:,2)';nseg_boun_mark(:)'];fprintf(poly_file,'%4d %6d %6d %3d\n',aux_segments);%fprintf(poly_file,'   %d\n',num_hole);iii=1:1:num_hole;aux_holes=[iii;hole_xy(:,1)';hole_xy(:,2)'];fprintf(poly_file,'%4d %14.6e %14.6e\n',aux_holes);%fprintf(poly_file,'   %d\n',num_region);iii=1:1:num_region;aux_regions=[iii;region_xy(:,1)';region_xy(:,2)';nregion_mark(:)';region_area(:)'];fprintf(poly_file,'%4d %14.6e %14.6e %5d %14.6e\n',aux_regions);fclose(poly_file);%% plot content of .poly file with Matlab%hold onfor i=1:num_boun_seg	xaux(1)=boun_point_xy(nseg_boun(i,1),1);	yaux(1)=boun_point_xy(nseg_boun(i,1),2);	xaux(2)=boun_point_xy(nseg_boun(i,2),1);	yaux(2)=boun_point_xy(nseg_boun(i,2),2);	plot(xaux,yaux,'bo-')endfor i=1:num_hole	text(hole_xy(i,1),hole_xy(i,2),'H')endfor i=1:num_region	text(region_xy(i,1),region_xy(i,2),num2str(nregion_mark(i)))end%%%%%%%%%%%%%%%%for i=1:num_boun_point    text(boun_point_xy(i,1),boun_point_xy(i,2),num2str(i))end%%%%%%%%%%%%%%%%title(strcat('POLY FILE - prefix = ',prefix))xlabel('x')ylabel('y')hold off%% create mesh with triangle (system call) %run_triangle=[triangle_exec,switch_trian,' ',prefix]; eval(run_triangle);%run_showme=['! showme ',prefix,'.1']; %eval(run_showme);%% open node file created by triangle%node_file_name=strcat(prefix,'.1.node');node_file=fopen(node_file_name,'r');   pars=sscanf(fgets(node_file),'%d %d %d %d');  numnp=pars(1);coor=zeros(numnp,2);node_mark=zeros(numnp,1);for i=1:numnp   pars=sscanf(fgets(node_file),'%d %f %f %d');     coor(i,1)=pars(2);   coor(i,2)=pars(3);   node_mark(i)=pars(4);end%% open element file created by triangle%ele_file_name=strcat(prefix,'.1.ele');ele_file=fopen(ele_file_name,'r');   pars=sscanf(fgets(ele_file),'%d %d %d');  numel=pars(1);lm=zeros(numel,nnopel);mat=zeros(numel,1);if nnopel == 3    for i=1:numel        pars=sscanf(fgets(ele_file),'%d %d %d %d %d');          lm(i,1)=pars(2);        lm(i,2)=pars(3);        lm(i,3)=pars(4);        mat(i)=pars(5);    endelse    for i=1:numel        pars=sscanf(fgets(ele_file),'%d %d %d %d %d %d %d %d');          lm(i,1)=pars(2);        lm(i,2)=pars(3);        lm(i,3)=pars(4);        lm(i,4)=pars(7);        lm(i,5)=pars(5);        lm(i,6)=pars(6);        mat(i)=pars(8);    endend%% open edge file created by triangle%edge_file_name=strcat(prefix,'.1.edge');edge_file=fopen(edge_file_name,'r');   pars=sscanf(fgets(edge_file),'%d %d');  numedge=pars(1);nedge_mark=zeros(numedge,1);nedge=zeros(numedge,2);num_edge=0;for i=1:numedge   pars=sscanf(fgets(edge_file),'%d %d %d %d');     iaux1=pars(1);   iaux2=pars(2);   iaux3=pars(3);   iaux4=pars(4);   %%%%%%%%   %%%%%%%%if iaux4>=11 && iaux4<=20 && value_imposed(iaux4)~=0      num_edge=num_edge+1;      nedge_mark(num_edge)=iaux4;      nedge(num_edge,1)=iaux2;      nedge(num_edge,2)=iaux3;   %%%%%%%%endendnumimp=0;for i=1:numnp   if node_mark(i)>=1 && node_mark(i)<=10      numimp=numimp+1;   endend %% create 'prefix.dat' file%dat_file_name=strcat(prefix,'.dat');dat_file=fopen(dat_file_name,'w');   numfs=num_edge;%fprintf(dat_file,'%s\n',problem_title);fprintf(dat_file,'   %d %d %d %d %d %d %d %d\n',nnopel,numnp,numel,numimp,numfs,numat,numipt,numgpt);iii=1:1:numnp;aux=[iii;coor(:,1)';coor(:,2)'];fprintf(dat_file,'%6d %18.8e %18.8e\n',aux);for i=1:numnp   if node_mark(i)>=1 && node_mark(i)<=10      fprintf(dat_file,'%d\n',i);   endendfor i=1:numnp   if node_mark(i)>=1 && node_mark(i)<=10      fprintf(dat_file,'%8d %17.6e\n',i,value_imposed(node_mark(i)));   endendfprintf(dat_file,'%8d %17.6e\n',0,0.0);aux=[akx(:)';aky(:)';q(:)'];fprintf(dat_file,'%14.6e %14.6e %14.6e\n',aux);iii=1:1:numel;if nnopel == 3    aux=[iii;mat(:)';lm(:,1)';lm(:,2)';lm(:,3)'];    fprintf(dat_file,'%6d %3d %6d %6d %6d\n',aux);else    aux=[iii;mat(:)';lm(:,1)';lm(:,2)';lm(:,3)';lm(:,4)';lm(:,5)';lm(:,6)'];    fprintf(dat_file,'%6d %3d %d %d %d %6d %6d %6d\n',aux);endiaux=zeros(4,1);iaux(1)=1;iaux(2)=2;iaux(3)=3;iaux(4)=1;for i=1:num_edge   n1=nedge(i,1);   n2=nedge(i,2);   if nedge_mark(i)>=11 && nedge_mark(i)<=20 && value_imposed(nedge_mark(i))~=0      for n=1:numel      for j=1:3         if lm(n,iaux(j))==n1 && lm(n,iaux(j+1))==n2            fprintf(dat_file,'%6d %3d %16.8e %16.8e\n',n,j,0.,value_imposed(nedge_mark(i)));         elseif lm(n,iaux(j))==n2 && lm(n,iaux(j+1))==n1            fprintf(dat_file,'%6d %3d %16.8e %16.8e\n',n,j,0.,value_imposed(nedge_mark(i)));         end      end      end   endendfor i=1:numgpt   fprintf(dat_file,'%f %f\n',sgt(i),tgt(i));end %% plot finite element mesh created by triangle%figure(2);clf;axis equal;xlabel('x')ylabel('y')area=0;hold on;for i=1:numel	xx(1)=coor(lm(i,1),1);	xx(2)=coor(lm(i,2),1);	xx(3)=coor(lm(i,3),1);	xx(4)=xx(1);	yy(1)=coor(lm(i,1),2);	yy(2)=coor(lm(i,2),2);	yy(3)=coor(lm(i,3),2);	yy(4)=yy(1);    aa=[1,xx(1),yy(1);1,xx(2),yy(2);1,xx(3),yy(3)];    area=area+0.5*det(aa);	plot(xx,yy,'b-','linewidth',1)end%%%%%%%%%%%%%% plot interfacesubd=30;specs.curve = 'k--';specs.width = 1;for i = 1:itrface.nNurbs    nurbs_plot(itrface.nurbs(i),subd,specs);end% plot boundary points%for i=1:num_boun_seg	xaux(1)=boun_point_xy(nseg_boun(i,1),1);	yaux(1)=boun_point_xy(nseg_boun(i,1),2);	xaux(2)=boun_point_xy(nseg_boun(i,2),1);	yaux(2)=boun_point_xy(nseg_boun(i,2),2);	plot(xaux,yaux,'ro-')end%%%%%%%%%%%%%%sprintf(' total domain area = %f\n',area)sprintf(' number of elements = %d\n',numel)av_elt_size=sqrt(area/numel);sprintf(' average element size h = %15.8f\n',av_elt_size)% Display element number%if(nargin>4 && showElem)    for i=1:numel        xx(1)=coor(lm(i,1),1);        xx(2)=coor(lm(i,2),1);        xx(3)=coor(lm(i,3),1);        yy(1)=coor(lm(i,1),2);        yy(2)=coor(lm(i,2),2);        yy(3)=coor(lm(i,3),2);        text((xx(1)+xx(2)+xx(3))/3,(yy(1)+yy(2)+yy(3))/3,num2str(i))    endend%% Display node number%if(nargin>3 && showNode)     for i=1:numnp        text(coor(i,1),coor(i,2),num2str(i),'fontsize',18)    endend%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% assignment to mesh variablemesh.node.node_n = 1:numnp;mesh.node.coords = [coor(:,1),coor(:,2)];mesh.node.n_node = numnp;mesh.node.Dirichlet.n_pre_temp = 0;for i=1:numnp   if node_mark(i)>=1 && node_mark(i)<=10      mesh.node.Dirichlet.n_pre_temp = mesh.node.Dirichlet.n_pre_temp+1;      mesh.node.Dirichlet.temp_node(mesh.node.Dirichlet.n_pre_temp) = i;      mesh.node.Dirichlet.temp_value(mesh.node.Dirichlet.n_pre_temp) = value_imposed(node_mark(i));   elseif node_mark(i)<0      mesh.node.Dirichlet.n_pre_temp = mesh.node.Dirichlet.n_pre_temp+1;      mesh.node.Dirichlet.temp_node(mesh.node.Dirichlet.n_pre_temp) = i;      mesh.node.Dirichlet.temp_value(mesh.node.Dirichlet.n_pre_temp) = itrface.pt_temp(-node_mark(i),2);   endendmesh.node.Dirichlet.temp_node = mesh.node.Dirichlet.temp_node';mesh.node.Dirichlet.temp_value = mesh.node.Dirichlet.temp_value';for i=1:numat    mesh.material(i).name = strcat(num2str(mat(i)));    mesh.material(i).density = [];     mesh.material(i).conductivity = akx(i); % akx(i)==aky(i)    mesh.material(i).specificHeat = [];     %mesh.material(i).heatSource = q(i); put this in each elementendiii=1:1:numel;mesh.elem.n_elem = numel;if nnopel == 3    mesh.elem.elem_n = iii;    mesh.elem.elem_node = [lm(:,1),lm(:,2),lm(:,3)];    mesh.elem.material = mat;else    mesh.elem.elem_n = iii;    mesh.elem.elem_node = [lm(:,1),lm(:,2),lm(:,3),lm(:,4),lm(:,5),lm(:,6)];    mesh.elem.material = mat;endiaux=zeros(4,1);iaux(1)=1;iaux(2)=2;iaux(3)=3;iaux(4)=1;mesh.elem.Neumann.n_heatFlux = 0;mesh.edge.edge_node = nedge; mesh.edge.length = find_edge_length(mesh.edge.edge_node,mesh.node.coords); % find half line width based on minimum edge length minEdgeLength = min(mesh.edge.length); halfLineWidth = 0.2*minEdgeLength;isConforming = true;itrface.tangent=find_line_source_tangent(itrface);disp('finding intersection points')to=cputime;[mesh.edge.itrsect,~] = edge_line_segs_intersect(nedge,mesh.node,itrface,...                            halfLineWidth,isConforming);elapsetime=cputime-to     mesh.elem.junc = [];                        % find the edges of the elementsmesh.elem.elem_edge = find_elem_edge(mesh.elem.elem_node,mesh.edge.edge_node);% find intersection points and enrichment nodesmesh.node.nOriginalNode = mesh.node.n_node;    %mesh.edge.itrsect=struct('num',cell(1,num_edge));for i=1:num_edge   n1=nedge(i,1);   n2=nedge(i,2);      %{   num = 0;   mesh.edge.itrsect(i).num = 0;    % find edge with intersection points   sItrsect = false;   eItrsect = false;      for j=1:num_boun_point       if(itrsect(j).nSeg==0)           continue       end       if(n1 == j)           sItrsect = true;           num = num+1;           mesh.edge.itrsect(i).num = num;           mesh.edge.itrsect(i).nSeg(num) = itrsect(j).nSeg;           mesh.edge.itrsect(i).seg{num} = itrsect(j).seg;           %mesh.edge.itrsect(i).pt(num) = itrsect(j).pt;           mesh.edge.itrsect(i).node(num) = j;           mesh.edge.itrsect(i).x(num) = boun_point_xy(j,1);           mesh.edge.itrsect(i).y(num) = boun_point_xy(j,2);           mesh.edge.itrsect(i).nurbsParam{num} = itrsect(j).nurbsParam;       end       if(n2 == j)           eItrsect = true;           num = num+1;           mesh.edge.itrsect(i).num = num;           mesh.edge.itrsect(i).nSeg(num) = itrsect(j).nSeg;           mesh.edge.itrsect(i).seg{num} = itrsect(j).seg;           %mesh.edge.itrsect(i).pt(num) = itrsect(j).pt;           mesh.edge.itrsect(i).node(num) = j;           mesh.edge.itrsect(i).x(num) = boun_point_xy(j,1);           mesh.edge.itrsect(i).y(num) = boun_point_xy(j,2);           mesh.edge.itrsect(i).nurbsParam{num} = itrsect(j).nurbsParam;       end       if(sItrsect && eItrsect)                      break;       end              end      %}   if nedge_mark(i)>=11 && nedge_mark(i)<=20 && value_imposed(nedge_mark(i))~=0      for n=1:numel          for j=1:3                         if (lm(n,iaux(j))==n1 && lm(n,iaux(j+1))==n2) ...               || (lm(n,iaux(j))==n2 && lm(n,iaux(j+1))==n1)                mesh.elem.Neumann.n_heatFlux = mesh.elem.Neumann.n_heatFlux+1;                mesh.elem.Neumann.heatFlux_elem(mesh.elem.Neumann.n_heatFlux)...                        = n;                %mesh.elem.Neumann.heatFlux_endNode(1:2,mesh.elem.Neumann.n_heatFlux)...                %        = [n1;n2];                mesh.elem.Neumann.heatFlux_surface{mesh.elem.Neumann.n_heatFlux}...                        = strcat('S',num2str(j));                    mesh.elem.Neumann.heatFlux_value(mesh.elem.Neumann.n_heatFlux)...                        = value_imposed(nedge_mark(i));             end          end      end   endend%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%fclose('all');end